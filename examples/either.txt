-- Source
let either =
  \f -> \g -> \x -> case x of inl a -> f a; inr b -> g b
in
either (\a -> inr a) (\b -> inl b) (inl 3)

-- CPS
-- Wow, this is kind of egregious.
-- (case analysis + nested applications, ugh.)
letfun either f k0 =
  letfun f1 g k1 =
    letfun f2 x k2 =
      letcont k3 a = f a k2 in
      letcont k4 b = g b k2 in
      case x of k3 | k4
    in
    k1 f2
  in
  k0 f1
in
letfun f3 a k5 = let v = inr a in k5 v in
letfun f4 b k6 = let v = inl b in k6 v in
letcont k7 z0 =
  letcont k8 z1 =
    let v = inl 3 in
    z1 v halt
  in
  z0 f4 k8
in
either f3 k7

-- CC
letfun {} either f k0 =
  letfun {f = f} f1 g k1 =
    letfun {f = f, g = g} f2 x k2 =
      letcont {f = f, k2 = k2} k3 a = f a k2 in
      letcont {g = g, k2 = k2} k4 b = g b k2 in
      case x of k3 | k4
    in
    k1 f2
  in
  k0 f1
in
letfun {} f3 a k5 = let v = inr a in k5 v in
letfun {} f4 b k6 = let v = inl b in k6 v in
letcont {f4 = f4} k7 z0 =
  letcont {} k8 z1 =
    let v = inl 3 in
      z1 v halt
    in
  in
  z0 f4 k8
in
either f3 k7

-- Hoist
-- ... and it only gets worse.
letcont {f, k2} k3_code a = f a k2 in
letcont {g, k2} k4_code b = g b k2 in
letfun {f, g} f2_code x k2 =
  letcont k3 = {f = f, k2 = k2} k3_code in
  letcont k4 = {g = g, k2 = k2} k4_code in
  case x of k3 | k4
in
letfun {f} f1_code g k1 =
  letfun f2 = {f = f, g = g} f2_code in
  k1 f2
in
letfun {} either f k0 =
  letfun f1 = {f = f} f1_code in
  k0 f1
in
letfun {} f3_code a k5 = let v = inr a in k5 v in
letfun f3 = {} f3_code
letfun {} f4_code b k6 = let v = inl b in k6 v in
letfun f4 = {} f4_code
letcont {} k8_code z1 =
  let v = inl 3 in
  z1 v halt
in
letcont {f4} k7_code z0 =
  letcont k8 = {} k8_code in
  z0 f4 k8
in
letcont k7 = {f4 = f4} k7_code in
either f3 k7

-- C

