-- Source
let fun fact n =
  if n == 0 then 1 else
  n * fact (n - 1)
in
  fact 5

-- CPS
letfun
  fact n k =
    if n == 0 then k 1 else
    let t0 = n - 1 in
    letcont
      k0 x0 =
        let t1 = n * x0 in
	k t1
    in
    fact t0 k0
in
fact 5 halt

-- CC
letfun
  {fact = fact}
  fact n k =
    if n == 0 then k 1 else
    let t0 = n - 1 in
    letcont
      {n = n, k = k}
      k0 x0 =
        let t1 = n * x0 in
	k t1
    in
    fact t0 k0
in
fact 5 halt

-- Hoist
letcont {n, k} k0_code x0 =
  let t1 = n * x0 in
  k t1
in
letfun {fact} fact_code n k =
  if n == 0 then k 1 else
  let t0 = n - 1 in
  letcont k0 = {n = n, k = k} k0_code in
  fact t0 k0
in
letfun fact = {fact = fact} fact_code
fact 5 halt

-- C
-- Section: Runtime support types and code.

typedef struct {} value
// TODO: Garbage collection
value *allocate_int32(int32_t x);
int32_t value_int32(value *v);

struct cont {
  void *env;
  void (*code)(void *env, value *arg);
};

struct cont *allocate_cont(void *env, void (*code)(void *env, value *arg)) {
  // TODO: Garbage collection
  struct cont *cont = malloc(1 * sizeof(struct cont));
  cont->env = env;
  cont->code = code;
  return cont;
}

struct fun {
  void *env;
  void (*code)(void *env, value *arg, struct cont *kont);
};

struct fun *allocate_fun(void *env, void (*code)(void *env, value *arg, struct cont *kont)) {
  // TODO: Garbage collection
  struct fun *fun = malloc(1 * sizeof(struct fun));
  fun->env = env;
  fun->code = code;
  return fun;
}

int main(void) {
  /* mystery */
}

-- Section: generated code.
-- Closure environments and code are hoisted to the toplevel.
struct k0_env {
  int32_t n;
  struct cont *k;
};

struct k0_env *allocate_k0_env(int32_t n, struct cont *k) {
  // TODO: Garbage collection
  struct k0_env *env = malloc(1 * sizeof(struct k0_env));
  env->n = n;
  env->k = k;
  return env;
}

void k0_code(void *env, value *arg) {
  struct k0_env *env0 = env;
  int32_t n = env0->n;
  struct cont *k = env0->k;

  -- unbox-rebox optimization opportunity?
  -- More generally, I would like smarter calling conventions than "pass one
  -- boxed value and continuation accepting one boxed value"
  -- * multiple arguments/CPR
  -- * unboxed arguments/results
  int32_t x0 = value_int32(arg);
  int32_t t1 = n * x0;
  value *v0 = allocate_int32(t1);
  -- __jump and __tailcall: implemented somehow.
  -- (could push on global stack, have main loop that pulls from stack until empty.)
  __jump(k, v0);
}

struct fact_env {
  struct fun *fact;
};

struct fact_env *allocate_fact_env(struct fun *fact) {
  struct fact *env = malloc(1 * sizeof(struct fact_env));
  env->fact = fact;
  return env;
}

void fact_code(void *env, int32_t n, struct cont *k) {
  struct fact_env *env0 = env;
  if (n == 0) {
    value *v0 = allocate_int32(1);
    __jump(k, v0);
  } else {
    int32_t t0 = n - 1;
    struct k0_env *env1 = allocate_k0_env(n, k);
    struct cont *k0 = allocate_cont(env1, k0_code);
    __tailcall(env0->fact, t0, k0);
  }
}

-- Entry point.
void __halt_code(void *env, value *arg) {
  int32_t retval = value_int32(arg);
  printf("result: %d\n", retval);
}

void entry(void) {
  // Need to recursively allocate these.
  // Use NULL as initial value for cycle.
  struct fact_env *fact_env = allocate_fact_env(NULL);
  struct fun *fact = alloc_fun(fact_env, fact_code);
  // Close the cycle.
  fact_env->fact = fact;

  struct cont *k = alloc_cont(NULL, __halt_code);
  value *t0 = allocate_int32(5);
  __tailcall(fact, t0, k);
}
